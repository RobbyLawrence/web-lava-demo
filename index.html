<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Procedural Lava • fBm + Voronoi + Domain Warping (WebGL)</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <h1>Procedural Lava</h1>
    <p>fBm • Voronoi • Domain Warping (WebGL)</p>
  </header>

  <main>
    <canvas id="glcanvas"></canvas>

    <aside id="panel">
      <div class="row">
        <label>Mode</label>
        <select id="mode">
          <option value="0">Lava (full)</option>
          <option value="1">fBm field</option>
          <option value="2">Voronoi cells (F1)</option>
          <option value="3">Crack mask (F2 - F1)</option>
          <option value="4">Warp visualizer</option>
        </select>
      </div>

      <div class="row">
        <label>Octaves <span id="octaves-val"></span></label>
        <input id="octaves" type="range" min="1" max="8" step="1" value="5">
      </div>

      <div class="row">
        <label>Lacunarity <span id="lacunarity-val"></span></label>
        <input id="lacunarity" type="range" min="1.2" max="3.0" step="0.05" value="2.0">
      </div>

      <div class="row">
        <label>Gain <span id="gain-val"></span></label>
        <input id="gain" type="range" min="0.25" max="0.85" step="0.01" value="0.5">
      </div>

      <hr/>

      <div class="row">
        <label>fBm Scale <span id="fbmScale-val"></span></label>
        <input id="fbmScale" type="range" min="0.2" max="6.0" step="0.05" value="1.6">
      </div>

      <div class="row">
        <label>Voronoi Scale <span id="voroScale-val"></span></label>
        <input id="voroScale" type="range" min="0.5" max="10.0" step="0.1" value="3.0">
      </div>

      <div class="row">
        <label>Crack Width <span id="crackWidth-val"></span></label>
        <input id="crackWidth" type="range" min="0.001" max="0.2" step="0.001" value="0.035">
      </div>

      <div class="row">
        <label>Warp Strength <span id="warpStrength-val"></span></label>
        <input id="warpStrength" type="range" min="0.0" max="1.0" step="0.01" value="0.35">
      </div>

      <div class="row">
        <label>Flow Speed <span id="flowSpeed-val"></span></label>
        <input id="flowSpeed" type="range" min="-1.0" max="1.0" step="0.01" value="0.22">
      </div>

      <div class="row">
        <label>Palette</label>
        <select id="palette">
          <option value="0">Classic Lava</option>
          <option value="1">Magma (darker)</option>
          <option value="2">Grayscale</option>
        </select>
      </div>

      <div class="row">
        <button id="fullscreen">Fullscreen</button>
        <button id="screenshot">Screenshot</button>
      </div>

      <p class="help">
        Tip: Use <strong>Warp Strength</strong> and <strong>Flow Speed</strong> to bring the lava to life. Switch modes to study each building block.
      </p>
    </aside>
  </main>

  <!-- Vertex Shader -->
  <script id="vs" type="x-shader/x-vertex">
  attribute vec2 aPos;
  varying vec2 vUV;
  void main() {
    vUV = (aPos + 1.0) * 0.5;        // map from clip-space to [0,1]
    gl_Position = vec4(aPos, 0.0, 1.0);
  }
  </script>

  <!-- Fragment Shader -->
  <script id="fs" type="x-shader/x-fragment">
  precision highp float;

  varying vec2 vUV;

  uniform vec2  iResolution;
  uniform float iTime;

  // Controls
  uniform int   uMode;           // 0 lava, 1 fBm, 2 F1, 3 cracks, 4 warp vis
  uniform int   uOctaves;        // 1..8
  uniform float uLacunarity;
  uniform float uGain;
  uniform float uFBMScale;
  uniform float uVoroScale;
  uniform float uCrackWidth;
  uniform float uWarpStrength;
  uniform float uFlowSpeed;
  uniform int   uPalette;

  // Hash helpers
  float hash11(float n) {
    return fract(sin(n)*43758.5453123);
  }
  float hash21(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
  }
  vec2  hash22(vec2 p) {
    p = vec2(dot(p, vec2(127.1, 311.7)),
             dot(p, vec2(269.5, 183.3)));
    return fract(sin(p) * 43758.5453123);
  }

  // Smooth interpolation
  vec2 smooth2(vec2 f){ return f*f*(3.0-2.0*f); }

  // 2D Value noise (tile-friendly if sampling on torus, but here plain)
  float valueNoise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec2 u = smooth2(f);
    float a = hash21(i + vec2(0.0, 0.0));
    float b = hash21(i + vec2(1.0, 0.0));
    float c = hash21(i + vec2(0.0, 1.0));
    float d = hash21(i + vec2(1.0, 1.0));
    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
  }

  // fBm with up to 8 octaves (use uniform to gate terms)
  float fbm(vec2 p, int octaves, float lac, float gain) {
    float s = 0.0;
    float a = 0.5;
    float f = 1.0;
    // Derivative-based attenuation to reduce aliasing at high freq
    // (approximate by fading last octaves as frequency grows)
    for (int i=0; i<8; ++i) {
      float m = float(i < octaves);
      s += a * valueNoise(p * f) * m;
      f *= lac;
      a *= gain;
    }
    return s;
  }

  // Voronoi (Worley) returning F1 and F2 (Euclidean)
  vec2 voronoiF1F2(vec2 x) {
    vec2 p = floor(x);
    vec2 f = fract(x);
    float F1 = 1e9;
    float F2 = 1e9;

    for (int j=-1; j<=1; ++j) {
      for (int i=-1; i<=1; ++i) {
        vec2 g = vec2(float(i), float(j));
        vec2 lattice = p + g;
        vec2 rnd = hash22(lattice);
        // jitter; center-ish + random
        vec2 q = rnd; // already [0,1)
        vec2 diff = g + q - f;
        float d = dot(diff, diff);
        if (d < F1) { F2 = F1; F1 = d; }
        else if (d < F2) { F2 = d; }
      }
    }
    return vec2(sqrt(F1), sqrt(F2)); // return true distances
  }

  // Domain warp using two low-frequency fbm channels
  vec2 warp(vec2 p) {
    float t = iTime * 0.6;
    vec2  w;
    // two decorrelated channels
    w.x = fbm(p * 0.75 + vec2(0.0, 3.1) + t*0.21, uOctaves, uLacunarity, uGain);
    w.y = fbm(p * 0.75 + vec2(5.2, 1.3) - t*0.17, uOctaves, uLacunarity, uGain);
    // shift to [-0.5,0.5]
    w = (w - 0.5) * 2.0;
    return w * uWarpStrength;
  }

  // Color palettes
  vec3 paletteClassic(float t) {
    // black -> red -> orange -> yellow -> near white
    t = clamp(t, 0.0, 1.0);
    vec3 c = vec3(0.0);
    // Use a smooth ramp with a little toe and shoulder
    float r = smoothstep(0.05, 0.25, t) + 0.6*t;
    float g = smoothstep(0.35, 0.85, t) * 0.9;
    float b = smoothstep(0.75, 1.0, t) * 0.4;
    c = vec3(r, g, b);
    // add hot core
    c += vec3(pow(t, 8.0))*0.6;
    return clamp(c, 0.0, 1.15);
  }
  vec3 paletteMagma(float t) {
    t = clamp(t, 0.0, 1.0);
    // darker, more red/orange
    vec3 c = mix(vec3(0.02,0.01,0.01), vec3(1.0,0.45,0.1), pow(t, 0.7));
    c += vec3(1.0)*pow(t, 8.0)*0.3;
    return clamp(c, 0.0, 1.15);
  }
  vec3 paletteGray(float t) {
    t = clamp(t, 0.0, 1.0);
    return vec3(t);
  }
  vec3 palette(float t) {
    if (uPalette == 0) return paletteClassic(t);
    if (uPalette == 1) return paletteMagma(t);
    return paletteGray(t);
  }

  void main() {
    // Normalize coords so 1 unit ≈ min(width,height)
    vec2 uv = (vUV * iResolution) / min(iResolution.x, iResolution.y);

    // add slow "advection" by panning
    float t = iTime * uFlowSpeed;
    vec2 adv = vec2(0.15, -0.09) * t;

    // Build signals
    vec2  pFBM = (uv + adv) * uFBMScale;
    vec2  w    = warp(pFBM);
    vec2  pV   = (uv + adv + w) * uVoroScale;

    float nBig   = fbm(pFBM * 1.0, uOctaves, uLacunarity, uGain);
    float nDetail= fbm(pFBM * 3.0 + 7.3, uOctaves, uLacunarity, uGain) * 0.5;

    vec2  F = voronoiF1F2(pV);
    float F1 = F.x;
    float F2 = F.y;
    float cracks = smoothstep(uCrackWidth, 0.0, F2 - F1); // thin near edges

    // Heat field: combine blobs, detail, and suppress at cracks
    float heat = clamp(nBig + 0.6*nDetail + (1.0 - F1)*0.4 - cracks*0.5, 0.0, 1.0);

    // Output by mode
    if (uMode == 1) {
      // fBm only
      float f = clamp(nBig + 0.6*nDetail, 0.0, 1.0);
      gl_FragColor = vec4(vec3(f), 1.0);
      return;
    }
    if (uMode == 2) {
      // Voronoi F1 as cells (lighter = closer to cell center)
      float v = 1.0 - clamp(F1, 0.0, 1.0);
      gl_FragColor = vec4(vec3(v), 1.0);
      return;
    }
    if (uMode == 3) {
      // Crack mask (white = crack lines)
      gl_FragColor = vec4(vec3(cracks), 1.0);
      return;
    }
    if (uMode == 4) {
      // Warp visualizer
      vec2 vis = 0.5 + 0.5*w;
      gl_FragColor = vec4(vis.x, vis.y, 0.5, 1.0);
      return;
    }

    // Lava composite
    float emiss = pow(heat, 3.2); // emphasize hot cores
    vec3  col   = palette(heat);
    // fake "emissive bloom" by lifting levels
    col += emiss * 0.6;

    // darken cracks
    col = mix(col, col*0.25, cracks);

    gl_FragColor = vec4(col, 1.0);
  }
  </script>

  <script src="app.js"></script>
</body>
</html>
